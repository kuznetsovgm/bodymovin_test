# План доработки бота: Postgres + Redis статистика для inline‑режима

## 1. Общие цели

- Сохранять пользователей в PostgreSQL (через TypeORM) при любом обращении к боту (inline, команды, callback и т.д.).
- Вести общую статистику использования стикеров в Redis:
  - счётчик отправок каждого стикера при `ChosenInlineResult` (без привязки к пользователю);
  - последние N (из конфигурации) отправленных стикеров для каждого пользователя (конкретные `sticker_file_id`);
  - общий скоринг вариантов стикеров по их конфигурации (без привязки к пользователю и конкретному `file_id`).
- При пустом inline‑запросе (`query === ''`) показывать персональную подборку из последних отправленных стикеров пользователя (по `file_id`), с возможной домешкой глобально популярных конфигураций.

## 2. Postgres + TypeORM: модель пользователя и интеграция

### 2.1. Модель пользователя

- Создать сущность `User` (TypeORM):
  - `id` (PK, UUID или serial).
  - `telegramId` (`bigint` / `varchar`, уникальный индекс).
  - `username`, `firstName`, `lastName` (nullable).
  - `languageCode` (из `ctx.from.language_code`, nullable).
  - `createdAt`, `updatedAt` (timestamp, audit).
- В БД хранится только информация о пользователях; вся статистика по стикерам — в Redis.

### 2.2. Настройка подключения к Postgres

- Добавить TypeORM в зависимости и создать модуль, например `src/db/orm.ts`:
  - Инициализация `DataSource`/`AppDataSource` на базе env‑переменных:
    - `PG_HOST`, `PG_PORT`, `PG_USER`, `PG_PASSWORD`, `PG_DB`.
  - Конфигурация миграций и синхронизации (миграции предпочтительнее).
- Добавить миграцию на создание таблицы `users`.

### 2.3. Хелпер для сохранения/обновления пользователей

- Создать сервис `UserService`:
  - `upsertFromContext(ctx)`:
    - извлекает `ctx.from` (`id`, `username`, `first_name`, `last_name`, `language_code`);
    - ищет пользователя по `telegramId`;
    - если не найден — создаёт;
    - если найден — обновляет изменившиеся поля;
    - обновляет `updatedAt`.
- Обеспечить безопасный вызов: в случае ошибки БД — логировать, но не срывать работу бота.

### 2.4. Где вызывать сохранение пользователей

- В `src/bot.ts` использовать middleware Telegraf:
  - создать `saveUserMiddleware`, который вызывает `await userService.upsertFromContext(ctx);` для всех апдейтов, где есть `ctx.from`;
  - подключить его глобально: `bot.use(saveUserMiddleware);`.
- Это гарантирует, что пользователь будет сохранён/обновлён при любом типе запроса (inline, команды, callback и т.д.) без дублирования логики в каждом handler’е.

## 3. Redis: структура данных для статистики

### 3.1. Общий счётчик отправок стикера

- При `ChosenInlineResult` увеличивать глобальный счётчик для стикера (без привязки к пользователю).
- Ключи:
  - Хеш: `sticker:stats`:
    - `field = <sticker_file_id>` (или другой уникальный ID стикера);
    - `value = count` (строка, увеличивается через `HINCRBY`).
  - Дополнительно (опционально) отсортированное множество для топа:
    - `key = sticker:stats:zset`;
    - `ZINCRBY sticker:stats:zset 1 <sticker_file_id>`.

### 3.2. Последние N отправленных стикеров пользователя

- N хранится в конфигурации (см. п. 4), далее обозначим как `USER_RECENT_LIMIT`.
- Ключи:
  - Список: `user:<telegram_id>:recent`:
    - `LPUSH user:<id>:recent <sticker_file_id>`;
    - `LTRIM user:<id>:recent 0 USER_RECENT_LIMIT-1`.
- Особенности:
  - Можно хранить не только `file_id`, но и JSON с доп. полями (например, `configId`), но для минимального решения достаточно `file_id`.

### 3.3. Индивидуальный скоринг пользователя
*(на этом этапе индивидуальный скоринг по пользователям **не внедряем**, фокус только на общей статистике)*

### 3.3. Общий скоринг конфигураций стикеров

- Отдельно от счётчика по `file_id` вести глобальный рейтинг по конфигурациям:
  - `key = sticker:config:score`;
  - `member = <config_id>` (ID конфигурации из Redis/StickerConfigManager);
  - `score` — количество выбранных пользователями стикеров с этой конфигурацией.
- При `ChosenInlineResult`:
  - определить `config_id` (по `result_id`/`configHash` или по заранее сохранённой мапе `file_id -> config_id`);
  - `ZINCRBY sticker:config:score 1 <config_id>`.
- В будущем этот рейтинг можно использовать для:
  - построения глобального топа конфигураций;
  - влияния на порядок выдачи результатов при непустых запросах (но на первом шаге можно просто собирать статистику).

## 4. Конфигурация: лимиты и feature‑флаги

- Расширить конфигурацию бота (хранится в Redis, через `StickerConfigManager`) параметрами:
  - `USER_RECENT_STICKERS_LIMIT` (по умолчанию 10).
  - `INLINE_HISTORY_ENABLED` (вкл/выкл выдачу истории по пустому запросу).
  - `INLINE_GLOBAL_CONFIG_SCORING_ENABLED` (вкл/выкл учёт глобального скоринга конфигураций).
- Где хранить:
  - только в Redis, рядом с уже существующими настройками в `StickerConfigManager` (добавить новые ключи/методы для чтения этих флагов).

## 5. Логика `ChosenInlineResult`

### 5.1. Обработчик события

- В `src/bot.ts` зарегистрировать:

  - `bot.on('chosen_inline_result', async (ctx) => { ... })`.

- Использовать `ctx.chosenInlineResult`:
  - `resultId` (может совпадать с `configHash`);
  - `from.id` — `telegramId`;
  - `inline_message_id`, `query` (по необходимости).

### 5.2. Действия в обработчике

1. Сохранить/обновить пользователя:
   - `await userService.upsertFromContext(ctx);`.
2. Обновить глобальную статистику стикера в Redis:
   - извлечь `sticker_file_id` (по `result_id` или из заранее сохранённой мапы `configHash -> file_id`);
   - `HINCRBY sticker:stats <file_id> 1`;
   - `ZINCRBY sticker:stats:zset 1 <file_id>`.
3. Обновить историю пользователя:
   - `LPUSH user:<id>:recent <file_id>`;
   - `LTRIM user:<id>:recent 0 USER_RECENT_LIMIT-1`.
4. Обновить глобальный скоринг конфигурации:
   - определить `config_id` для данного результата;
   - если `INLINE_GLOBAL_CONFIG_SCORING_ENABLED` включен — `ZINCRBY sticker:config:score 1 <config_id>`.
5. Логирование:
   - логировать `userId`, `fileId`, `query`, время.

## 6. Пустой inline‑запрос: выдача истории/рекомендаций

### 6.1. Определение пустого запроса

- В существующем обработчике `bot.on('inline_query', ...)`:
  - `const query = ctx.inlineQuery.query.trim();`
  - Если `query === ''`:
    - вместо генерации по тексту пробовать отдать историю/рекомендации.

### 6.2. Получение кандидатов из Redis

- Для пользователя `id = ctx.from.id`:
  - Последние N:
    - `LRANGE user:<id>:recent 0 USER_RECENT_LIMIT-1`.
- Итоговый список:
  - использовать только персональные последние `file_id` (это строго личная история);
  - ограничить итоговый список до лимита inline‑ответа (например, 20);
  - опционально дополнить список несколькими глобально популярными конфигурациями, если включён `INLINE_GLOBAL_CONFIG_SCORING_ENABLED` (на основе `sticker:config:score`), конвертируя их в конкретные `file_id` при необходимости.

### 6.3. Построение `InlineQueryResult[]`

- Для каждого `file_id`:
  - сформировать `InlineQueryResultCachedSticker`:
    - `type: 'sticker'`;
    - `id: <stable_id>` (можно взять `file_id` или `configHash`);
    - `sticker_file_id: <file_id>`.
- Ответить через `ctx.answerInlineQuery(results, { is_personal: true, cache_time: 0 });`
  - `cache_time` можно сделать небольшим (или 0), чтобы история обновлялась чаще.

### 6.4. Fallback

- Если у пользователя нет истории (новый пользователь):
  - либо вернуть пустой список (Telegram покажет подсказку),
  - либо fallback к текущему поведению (например, генерировать стикеры с дефолтным текстом/подсказкой или показывать глобально популярные конфигурации).

## 7. (в перспективе) Индивидуальный скоринг

- На текущем этапе индивидуальный скоринг пользователей откладывается.
- При необходимости в будущем можно:
  - добавить `sorted set` `user:<telegram_id>:score` с весами по `file_id` или `config_id`;
  - использовать этот скоринг для персонального ранжирования результатов при непустых запросах.

## 8. Логирование и мониторинг

- Добавить метрики/логи:
  - количество сохранённых пользователей;
  - количество событий `chosen_inline_result`;
  - количество обращений к истории (`empty_query_hits`);
  - количество успешных/ошибочных операций Redis/Postgres.
- В `metrics.ts` добавить:
  - Counters для:
    - `inline_chosen_total{status=...}`;
    - `user_updates_total{status=...}`;
    - `inline_history_total{status=..., type=personal|global}`.

## 9. Этапы внедрения

1. **Инфраструктура БД:**
   - поднять PostgreSQL (отдельный сервис в `docker-compose.yml` или внешний);
   - добавить TypeORM и настроить подключение;
   - создать миграцию и таблицу `users`.
2. **UserService и middleware:**
   - реализовать сущность `User`, сервис `UserService`;
   - подключить глобальный middleware `bot.use(saveUserMiddleware)` для сохранения пользователей.
3. **Redis‑структуры и handler `chosen_inline_result`:**
   - реализовать хелперы для инкремента счётчика по `file_id` и глобального скоринга по `config_id`;
   - добавить обработчик `bot.on('chosen_inline_result', ...)`;
   - убедиться, что есть доступ к `sticker_file_id` (при необходимости завести мапу `configHash -> file_id`).
4. **Пустой inline‑запрос и персональная выдача:**
   - реализовать выборку истории (последних `file_id`) из Redis;
   - интегрировать логику в `inline_query` при `query === ''`;
   - добавить fallback на глобальную популярность.
5. **Тонкая настройка и документация:**
   - добавить описание новых ключей/флагов Redis в `redis-config.md` и общих docs;
   - описать миграции и требования к PostgreSQL;
   - при необходимости расширить `redis-config.md` описанием новых ключей.
